### 浏览器内部工作原理

https://kb.cnblogs.com/page/129756/
https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/
http://taligarsiel.com/Projects/howbrowserswork1.htm

- 浏览器主要包括：用户界面、浏览器引擎、渲染引擎、网络、UI后端、js解释器、数据存储

- 渲染引擎：
用来渲染，在浏览器窗口显示请求的内容。例如webkit和Geoko

    - 渲染的步骤：解析并构建DOM树，创建render树，布局render树(渲染对象组成的树)，渲染render树。

    - 具体操作：开始解析html，将标签解析成对应DOM树中的节点；然后解析外部css文件和style标签中的样式，加上其他可见指令并生成对应的render树；然后布局render树，确定每个节点在屏幕上的坐标；遍历整个render树，使用UI后端层绘制每个节点。

    - 渲染过程会今早将内容呈现到屏幕上，并不会等所有的html都解析完成后再构建和布局render树，而是解析一部分显示一部分。

- 解析与DOM树的构建：

    - 解析：将文档转换为具有一定意义编码可以理解和使用的结构的过程。解析的结果通常是表达文档结构的节点树，称为解析树或者是语法树。

    - 文法：  解析基于文档依据的语法规则—文档的语言或格式。每种可被解析的格式，必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。

    - 解析器--词法分析器：
解析分为两个步骤：词法分析--将输入分解为符号，符号是语言的词汇表，是最基本的有效单元的集合；语法分析--对语言应用语法规则。
词法分析器负责将输入分解为合法的符号，根据语言的羽凡分析文档结构，从而构建解析树，知道如何跳过空白，换行符等。解析的过程是迭代的，如果取到的符号匹配语法规则，则解析为对应的节点，放入解析树上。如果没有匹配，则在内存保存符号，直到内存中有能够与它匹配的符号为止。

    - 转换：解析树并不是最终结果。解析一般在转换中使用--将输入文档转换为另一种格式。如编译，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，再将解析树转换为机器码。

    - 词汇表通常用正则表达式定义。

    - 解析器的类型：自顶向下解析和自底向上解析。

    - 自动化解析：解析生成器是可以用来生成一个解析器的工具，2333。webkit有两个生成器：用于创建语法分析器的flex和创建解析器的bison。Flex的输入是包含了符号定义规则的正则表达式，Bison的输入时用BNG格式表达的词法规则。
    - HTML解析器：用来将html标识解析为解析树。
    - HTML文法定义：W3C组织制定的，用来规范定义HTML的词汇表和语法。

    - 非上下文无关文法：上下文无关文法可以用类似BNF的格式定义，然而，HTML不能单纯的用解析器所需的上下文无关文法来定义。HTML有一个正式的格式定义--DTD（Dcoument Type Definition 文档类型定义）--不是上下文无关文法，更接近于xml，html有个xml变体--xhtml。但HTML更宽容，可以省略一些开始和结束标签，xhtml则要求标签必须正确嵌套，一一对应。
    - HTML与 DTD ：HTML适用于DTD格式，这种格式适用于定义SGML家族的语言，HTML和xml同样派生与SGML，xml是DTD的一个子集，而HTML是DTD的一个应用。引于维基百科：https://zh.wikipedia.org/wiki/SGML
    - DTD格式也有一些变种，标准模式为了遵循规范，为了兼容以前的内容，其他派生出来的变种包含了浏览器对于过去使用标签的支持。
    - DOM：解析树是由DOM元素及属性节点组成的。DOM是文档对象模型的缩写，是HTML文档的对象表示，可以作为HTML元素的外部接口供js调用。DOM树的根节点是document对象。DOM和标签基本一一对应。
    - HTML不能被一般的自顶向下或自底向上的解析器解析的原因：
HTML本身有宽容的特性；对常见的非法HTML有容错机制；解析的过程是往复的，源码不会在解析的过程中发生改变，但在HTML中，脚本标签中的例如document.write会添加标签，说明在解析的过程中实际上修改了输入。
因为不能使用正则解析，所以THML定制了专属的解析器；HTML5规范中描述了这个解析算法，算法包括两个阶段：符号化--是词法分析器的过程，将输入解析为符号，HTML的符号包括开始标签、结束标签、属性值，然后将识别出的符号传递给树构建器，并读取下一个字符，以识别下一个符号，直至处理完所有输入。

    - 符号识别算法：
算法输出HTML符号，该算法用状态机表示。每次读取输入流中的一个或者多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响着结果，所以同样的字符可能因为当前状态的不同而不同。
例如  包含html和body标签的简单页面
<html>
    - <body>
    - Hello world
</body>
    - </html>

    - 　初始状态为“Data State”，当遇到“<”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“>”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。
当读取到“>”，当前的符号就完成了，此时，状态回到“Data state”，“<body>”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会为“Hello world”中的每个字符生成一个字符符号。
这样直到遇到“</body>”中的“<”。现在，又回到了“Tag open state”，读取下一个字符“/”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“>”。然后，产生一个新的标签符号并回到“Data state”。后面的“</html>”将和“</body>”一样处理。

    - 树的构建算法：
在树的构建阶段，将修改以Document为根的DOM树，将元素附加到树上。树构造器处理被符号识别算法识别的符号，按照规范定义的对应规则，创建相应DOM元素，将元素添加到DOM树和开放元素堆栈中。该堆栈用来纠正没有争取匹配的嵌套，和没有闭合的标签，这个算法也用状态机来描述，状态采用插入模式。
<html>
    - <body>
    - Hello world
</body>
    - </html>
    - 首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。
状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。
现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。
然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。
接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。

    - 当解析结束后，浏览器将文本标记为可交互的，并开始解析处于延时模式中的脚本。文档状态被设置为以完成以后会触发load事件。

    - 浏览器的容错：<br>错写成</br>、表格嵌套表格并不在br中、表单嵌套表单等
    - css解析：
css属于上下文无关语法，每一个符号都由正则表达式定义词法文法。
    - webkit css解析器：webkit利用flex和bison解析生成器从css语法文件中自动生成解析器。Bison创建一个自底向上的解析器，fireFox使用自顶向下的解析器。将每一个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。

    - 处理脚本及样式表的顺序：
web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析知道脚本执行完毕。如果脚本的外部引用，则网络必须先请求到这个资源--这个过程是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了多年，并且在HTML4和HTML5中特别指定了。开发者可以将脚本标识为dfer，使其不会阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另外一个线程。

    - 预解析：
执行脚本时，另一个线程会解析剩下的文档，并加载后面需要通过网络加载的资源。预解析并不改变DOM树，改变DOM树的工作会让主解析过程进行，预解析时只解析外部资源的引用，如外部脚本样式表以及图片。

    - 样式表：
样式表采用另一种不同的模式。由于样式表并不会影响DOM树，所以样式表不必等样式表加载完成后再解析DOM树，然而如果脚本在解析的过程中，请求了还没有加加载和解析的样式，会产生问题。所以Firefox存在在样式表还在加载和解析式阻塞脚本的情况，儿Chrome只在当前脚本试图访问某些可能未被加载的样式时才会阻塞脚本。

- 渲染树（Render tree）的构建
当DOM树构建完成时，浏览器开始创建渲染树。渲染树由元素显示列表中的可见元素组成，它是可视化的表示，这棵树的作用是以正确的顺序绘制文档内容。渲染树在Firefox中成为frames，webkit中用renderer或者渲染对象来描述这些元素。渲染树和Dom树的关系，每个渲染对象用一个和该节点的css盒模型相对应的矩形区域表示，包含各种高宽之类的几何信息。盒模型的类型受该节点相关的display样式属性的影响。

    - 渲染树和Dom树的关系：
渲染对象和Dom元素相对应，然而并不是一一对应，不可见的DOM元素不会被插入渲染树，如head元素。display：none也不会被渲染。visibility：hidden会渲染。有些DOM元素有复杂的结构元素，无法用矩形表示。
例如浮动和绝对定位的元素在文本流之外，两棵树的位置不同，渲染树上标识出真实的结构，并用一个展位结构标识出他们原来的位置。

    - 创建树的流程：
Firefox中，表述为一个监听DOM更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式并且创建一个frame。
webkit中，计算样式并生成渲染对象的过程称为attachment，每个DOM节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法将节点插入到DOM树中。
整个树的根标签--html和body标签被称为containing block（包含所有其他块元素的顶级元素）。大小就是浏览器窗口显示区域。Firefox称它为viewPortFrame，webkit称为RenderView，这个就是文档所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。

    - 样式计算：
创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。样式包括各种来源的样式表，行内样式元素及html中的可视化属性，可视化属性转换为css样式属性。样式表由浏览器默认，和开发者提供的样式提供。

    - 共享样式数据：webkit节点引用样式对象（渲染样式），可以被兄弟或者表兄弟节点共享。需要满足一定的条件如：处于相同的鼠标状态、id不相同、标签名匹配、class属性匹配、对应的属性相同、联机状态匹配、焦点状态匹配、没有元素属性被选择器影响、元素不能有行内样式属性、不能有生效的兄弟选择器。
    - Firefox规则树
Firefox用两个树来简化样式计算，规则树和样式上下文树，webkit用dom节点指定相关样式。
样式上下文包含最终值，以正确的应用匹配的规则，转换为具体的值，如百分比转换为绝对单位。而匹配规则存储在规则树中，树的底层节点优先级最高，规则树中包含了找到的所有规则匹配的路径。

    - 结构化：样式上下文按结构划分，这些结构包括类似border或color这样的特定分类的样式信息。一个结构中的所有特性分为继承和非继承。继承一般层parent中，非继承没有定义用默认值。样式上下文树缓存完整的结构，如果底层节点没有为机构定义，则使用上层节点缓存的结构。

    - 使用规则树计算样式上下文：
当作为一个特定的元素计算样式的时候，首先计算出规则树种的一条路径，或者是使用已经存在的一条，然后使用路径中的规则填充新的样式上下文，从样式的底层开始，遍历规则树，直到填满结构。如果在规则节点没有定义所需的结构规则，沿路径向上，直到找到该结构规则。如果找不到定义，继承型的继承父节点结构，非继承型的用默认值。节点添加值得时候，需要额外计算将其转化为实际值，然后在树上的节点缓存该值。当一个元素和它的兄弟元素指向同一个树的节点时，完整的上下文可以被共享。
如：
<html>
    -   <body>
    -     <div class="err" id="div1">
    -       <p>this is a
    -         <span class="big"> big error </span>
    -         this is also a
        <span class="big"> verybigerror</span>
    -         error
      </p>
    -     </div>
    -     <div class="err" id="div2">another error</div>
    -   </body>
    - </html>
    - 1.div {margin:5px;color:black}
2..err {color:red}
3..big {margin-top:3px}
4.div span {margin-bottom:4px}
5.#div1 {color:blue}
6.#div2 {color:green}
生成的规则树如下：
生成的上下文树如下：
假设我们解析html，遇到第二个div标签，我们需要为这个节点创建样式上下文，并填充它的样式结构。
我们进行规则匹配，找到这个div匹配的规则为1、2、6，我们发现规则树上已经存在了一条我们可以使用的路径1、2，我们只需为规则6新增一个节点添加到下面（就是规则树中的F）。

    - 　　然后创建一个样式上下文并将其放到上下文树中，新的样式上下文将指向规则树中的节点F。
    - 　　现在我们需要填充这个样式上下文，先从填充margin结构开始，既然最后一个规则节点没有添加margin结构，沿着路径向上，直到找到缓存的前面插入节点计算出的结构，我们发现B是最近的指定margin值的节点。因为已经有了color结构的定义，所以不能使用缓存的结构，既然color只有一个属性，也就不需要沿着路径向上填充其他属性。计算出最终值（将字符串转换为RGB等），并缓存计算后的结构。
第二个span元素更简单，进行规则匹配后发现它指向规则G，和前一个span一样，既然有兄弟节点指向同一个节点，就可以共享完整的样式上下文，只需指向前一个span的上下文。
因为结构中包含继承自parent的规则，上下文树做了缓存（color特性是继承来的，但Firefox将其视为reset并在规则树中缓存）。
例如，如果我们为一个paragraph的文字添加规则：
p {font-family:Verdana;font size:10px;font-weight:bold}
那么这个p在内容树中的子节点div，会共享和它parent一样的font结构，这种情况发生在没有为这个div指定font规则时。
Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。
总结一下，共享样式对象（结构中完整或部分内容）解决了问题1和3，Firefox的规则树帮助以正确的顺序应用规则。

    - 对规则进行处理以简化匹配过程：
样式表解析完成后，规则会根据选择符添加一些hash映射，映射是可以根据id、class、标签名或任何不属于这些分类的综合映射。这样可以简化匹配规则，不需要查看声明就可以在映射中找到相关规则，大大减少了工作量。

    - 以正确的级联顺序应用规则：
样式对象拥有对应所有可见属性的属性，如果特性没有被热河匹配的规则定义，那么可以从父节点继承或使用默认值。用级联顺序可以解决不在一处定义特性值的问题。

    - 样式表的级联顺序：
用户important>作者important>作者的一般声明>用户声明>浏览器声明
浏览器声明是最不重要的，用户只有在声明被标记为important时才会覆盖作者的声明。具有同等级别的声明将根据specifity以及它们被定义时的顺序进行排序。Html可视化属性将被转换为匹配的css声明，它们被视为最低优先级的作者规则。
    - Specifity
CSS2规范中定义的选择符specifity如下：详见css权威指南

    - 规则排序：
规则匹配过后，需要根据级联顺序对规则进行排序，webkit先将小列表用冒泡排序，再将他们合并为一个大列表，webkit通过为规则复写“>”操作来执行排序。

    - 逐步处理Gradual process
webkit使用一个标志位标识所有顶层样式表都已加载，则放置占位符，并在文档中标记，一旦样式表完成加载就重新进行计算。

- 布局layout
当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程被称为layout或者reflow。Html使用基于流的布局模型，意味着大部分的时间，可以以单一的途径进行几何运算。流中考后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从左向右、自上而下的进行。tables例外。
坐标系统基于frame，使用top和left坐标。布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个layout或reflow方法，每个渲染对象调用需要布局的children的layout方法。
    - Dirty bit系统：
当一个渲染对象发生变化或被添加，此对象及其子对象标识为dirty，需要重新渲染。children are dirty说明即使这个渲染对象可能没问题，但它至少有一个child需要layout。

    - 全局和增量layout
当layout在整棵渲染树触发的时候，称为全局layout。比如字号的改变。增量layout会在渲染对象dirty时异步触发，例如在网络接收到新的内容并添加到DOM树以后，新渲染的对象会添加到渲染树中。

    - 异步和同步的layout
增量layout的过程是异步的，Firefox为增量layout生成了reflow队列，以及一个调度执行这些批处理命令。webkit也有一个计时器用来执行layout遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如offsetHeight，会同步触发增量布局。全局layout一般同步触发，有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。

    - 优化：
当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。
    - layout过程：
1. parent渲染对象决定它的宽度
2. parent渲染对象读取chilidren，并：
  a. 放置child渲染对象（设置它的x和y）
  b. 在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度
  c. parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用
  d. 将dirty标识设置为false
Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。
Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。

    - 宽度计算：
渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。
    - webkit中宽度的计算过程是（RenderBox类的calcWidth方法）：
        - - 容器的宽度是容器的可用宽度和0中的最大值，这里的可用宽度为：contentWidth=clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小
        - - 元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值
        - - 加上水平方向上的border和padding到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。
    - Line breaking
当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。

- 绘制：

    - 全局和增量：
和布局一样，绘制可以使全局的也可以是增量的。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统

    - 绘制顺序：
css2定义了绘制过程的顺序，这是元素亚茹堆栈的顺序，这个顺序影响绘制，堆栈从后向前进行绘制。一个渲染对象的堆栈顺序是：背景色、背景图、border、children、outline。
    - Firefox显示列表：
firefox读取渲染树并为绘制的矩形创建一个显示列表，该列表以争取的绘制顺序包含这个矩形相关的渲染对象。
用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。
Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。
    - WebKit矩形存储
重绘前，WebKit将旧的矩形保存为位图，然后只绘制新旧矩形的差集。

- 动态变化：
浏览器总是试着以最小的动作相应一个变化，所以一个元素颜色的变化只导致该元素的重绘，元素位置的变化或者新增DOM节点，将导致元素重新的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而引起整数的布局和重绘。

- 渲染引擎的线程：
渲染引擎是单线程的，除了网络操作以外，几乎所有的事情都在单线程中处理，在Firefox和Safari中，这是浏览器的主线程，Chrome中这是tab的主线程。网络操作由几个并行的线程执行，并行链接的个数是有限的（2-6个）

    - 事件循环：
浏览器的主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，用来等待事件（如layout和paint事件）并执行他们。
- CSS2可视模型

    - 画布：canvas用来描述格式化的结构所渲染的空间--浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。
    - CSS盒模型

    - 定位策略：
定位策略有三种
normal
float
absolute
static和relative是normal，absolute和fixed属于absolute。static中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。
Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。
    - Box类型：
block、inline
    - position:
relative：相对定位——先按照一般的定位，然后按所要求的差值移动。
    - Floats：
    - absolute、fixed
    - layered representation
css中的z-index指定